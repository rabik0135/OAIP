															//В матрице размером n*m упорядочить строки по возрастанию их наибольших элементов.
#include <iostream>
using namespace std;

int main()
{
	setlocale(LC_ALL, "rus");

	int n, m, j, k;
	double **array, *pr, *max, r;													//Переменная *pr используются для перестановки строк
																					//Переменная r используется для перестановки значений максимальных элементов
	cout << "Введите количество столбцов: ";
	while (!(cin>>m)||(m<1))														//Проверка на ввод количества столбцов
	{
		cout << "Введено неверное значение. Введите значение заново." << endl;
		cin.clear();
		cin.ignore();
		cin >> m;
	}
	
	cout << "Введите количество строк: ";
	while (!(cin >> n) || (m < 1))													//Проверка на ввод количества строк
	{
		cout << "Введено неверное значение. Введите значение заново." << endl;
		cin.clear();
		cin.ignore();
		cin >> n;
	}
	
	array = new double*[n];														//Выделение памяти под n указателей(строк)
	for ( j = 0; j < n; j++)
	{
		array[j] = new double [m];												//выделение памяти под m элементов каждой строки(столбцов)
	}

	for ( j = 0; j < n; j++)													//Ввод массива
	{
		for ( k = 0; k < m; k++)
		{
			cout << "Введите элемент ["<<j+1<<"]["<<k+1<<"]: ";
			cin >> array[j][k];
		}
	}
	
	cout << "\nНачальный массив:\n";
	
	for (j = 0; j < n; j++)														//Вывод массива
	{
		for (k = 0; k < m; k++)
		{
			cout <<array[j][k]<<" ";
		}
		cout << endl;
	}

	cout << endl;
	max = new double[n];														//Выделение памяти для одномерного динамического массива максимальных элементов
	
		for (j = 0; j < n; j++)													//Поиск максимального элемента в каждой строке
		{
			max[j] =DBL_MIN ;													//Значению максимального элемента строки присваивается минимальное значение для типа double(для нахождения максимального элемента в строке)
			for (k = 0; k < m; k++)
			{
				if (array[j][k] > max[j])										//Если значение проверяемого элемента больше максимального элемента
				{																
					max[j] = array[j][k];										//То максимальному элементу присваивается значение проверяемого элемента
					
				}
			}
			printf("Максимальное значение %d строки: %.2lf \n", j + 1, max[j]);	//Вывод максимального значения каждой строки
		}
		
		//Сортировка строк по максимальному элементу методом пузырька
		
		for ( j = 0; j < n-1; j++)											

		{
			for (k = j + 1; k < n; k++)
			{
				if (max[j] > max[k])											//если максимальный элемент строки больше максимального элемента следующей строки то выполняется перестановка строк
				{
					r = max[j]; max[j] = max[k]; max[k] = r;					//Перестановка j-го и k-го значений массива максимальных элементов 
					pr = array[j]; array[j] = array[k]; array[k] = pr;			//Перестановка j-й и k-й строк массива с помощью указателей
				}
			
			}
		}
		
		cout <<"\nОтсортированный массив:\n";
		
		for (j = 0; j < n; j++)													//Вывод отсортированного массива
		{
			for (k = 0; k < m; k++)
			{
				cout <<array[j][k] << " ";
			}
			cout << endl;
		}
	
		for ( j = 0; j < n; j++)												//Освобождение памяти, занятой под элементы 
			delete[] array[j];
	
			delete[] array;														//Освобождение памяти, занятой под указатели
		
	delete[]max;																//Освобождение памяти массива максимальных элементов	
}